#!/usr/bin/env python3

###################################################################
#
# Name:  postProcessCGPM.py
#
# Programmer:  Carol L. Ecale Zhou 
#
# Last update:  21 December 2020
#
# Description:
# This program post-processes the output file produced by code
# compareGeneProfiles_main.py, "compareGeneProfiles_main.report".
# The output of postProcessCGPM.py is a report specifying the 
# following:
#    * gene matches
#    * potential split gene calls
#    * potential overlapping genes or alternative start sites
#    * possible missing fractions of genes
#    * possible missed gene calls
#    * possible missed matching genes (loner similarity by annotation)
#    * paralogs
#    * triplets (geneA -- relationship -- geneB) 
#
# Input parameters, format specifications, and default values:
# Files:
#    genome sequence files (in multi-fasta format; -g1 and -g2)
#    input report file generated by compareGeneProfiles_main.py
#
# Output: postProcessCGPM.report, containing report as described above
#
###################################################################
# This code was developed by Carol L. Ecale Zhou at Lawrence Livermore National Laboratory.
# THIS CODE IS COVERED BY THE GPL3 LICENSE. SEE INCLUDED FILE GPL-3.PDF FOR DETAILS.

import sys, os, re, string, copy
import fastaSequence

# Boolean control
PHATE_PROGRESS = False
PHATE_MESSAGES = False
PHATE_WARNINGS = False
PHATE_PROGRESS_STRING = os.environ["PHATE_PHATE_PROGRESS"]
PHATE_MESSAGES_STRING = os.environ["PHATE_PHATE_MESSAGES"]
PHATE_WARNINGS_STRING = os.environ["PHATE_PHATE_WARNINGS"]
if PHATE_PROGRESS_STRING.lower() == 'true':
    PHATE_PROGRESS = True
if PHATE_MESSAGES_STRING.lower() == 'true':
    PHATE_MESSAGES = True
if PHATE_WARNINGS_STRING.lower() == 'true':
    PHATE_WARNINGS = True

##### FILES

LOGFILE = open("./postProcessCGPM.log","w")
today = os.popen('date')
LOGFILE.write("%s\n" % (today.read()))
REPORT_FILE = "./postProcessCGPM.report" 

##########################################################################
##### PATTERNS

p_fasta   = re.compile('\.(fasta)|(fna)|(fas)|(fnt)|(fa)|(faa)')
p_report  = re.compile('\.report')
p_comment = re.compile('^#')

########################################################################
##### DECLARATIONS 

##### CONSTANTS
 
HELP_STRING = "This program post-processes a report file, called compareGeneProfiles.report, produced by code,\ncompareGeneProfiles_main.py. The output of postProcessCGPM.py is a report specifying the following:\n   * gene matches\n   * potential split gene calls\n   * potential overlapping genes or alternative start sites\n   * possible missing fractions of genes\n   * possible missed matching genes\n   * possible missing gene calls\n   * possible missed matching genes (loner similarity by annotation)\n   * paralogs\n   * triplets (geneA -- relationship -- geneB)\nNote: some feature are under construction."
 
USAGE_STRING = "Usage:  postProcessCGPM.py <g1_gene_file.fa> <g2_gene_file.fa> <compareGeneProfiles_main.report>\nOr, postProcessCGPM.py -g1 <g1_gene_file.fa> -g2 <g2_gene_file.fa> -r <reportFile.report>\nType: postProcessCGPM.py help, for more information>" 

INPUT_STRING = "You may enter parameters interactively (via prompt) by typing: compareGeneProfiles_main.py -interactive\n"   

ACCEPTABLE_ARG_COUNT = (2,4,7) # 2 if "help", "input", or "interactive" 

#DEBUG = True
DEBUG = False

##### VARIABLES

# Fill these in later for user-defined parameters
parameters = { # defaults as indicated
    "COVERAGE_DIFF"           : 20,
    "NEARLY_FULL"             : 98,
    "START_DIFF"              : 20,
    "SIMILAR_GENOMES"         : True 
}

files = { # User's input files go here
"geneFile1"     : "",
"geneFile2"     : "",
"inReportFile"  : "",
"outReportFile" : "postProcessCGPM.report"
}

fileError = False    # assume all is ok until proven otherwise

##### DATA STRUCTURES


##### FUNCTIONS ##############################################################

# Function GetArguments

def GetArguments(parameters,files):
    # get Files
    sys.stdout.write("Please enter the filename for genome #1 gene fasta sequences:")
    files["geneFile1"] = sys.stdin.readline().rstrip()
    sys.stdout.write("Genome #2 gene fasta sequence filename:")
    files["geneFile2"] = sys.stdin.readline().rstrip()
    sys.stdout.write("Please enter the report from compareGeneProfiles_main.py:")
    files["inReportFile"] = sys.stdin.readline().rstrip()
    GET_PARAMS = False
    sys.stdout.write("Do you want to accept all defaults? enter y/n  ")
    decision = sys.stdin.readline().rstrip()
    if decision.lower() == "n" or decision.lower() == "no":
        GET_PARAMS = True 
    # get Parameters
    if GET_PARAMS:
        pass

################################################################################
# Get command-line arguments
################################################################################

if PHATE_PROGRESS:
    print("cgp_postProcessCGPM says, Reading input parameters.")

argCount = len(sys.argv)
if argCount in ACCEPTABLE_ARG_COUNT:
    match = re.search("help", sys.argv[1].lower())
    if match:
        print (HELP_STRING)
        print (USAGE_STRING)
        LOGFILE.close(); exit(0)
    match = re.search("input", sys.argv[1].lower())
    if match:
        print (INPUT_STRING)
        LOGFILE.close(); exit(0)
    match = re.search("interactive", sys.argv[1].lower())
    if match:
        GetArguments(parameters,files)
    elif argCount == 4:  # arguments must be in order
        files["geneFile1"] = sys.argv[1]
        files["geneFile2"] = sys.argv[2]
        files["inReportFile"] = sys.argv[3]
    elif argCount == 7:  # arguments follow argument identifier
        for i in range(argCount):
            if sys.argv[i] == "-g1":
                files["geneFile1"] = sys.argv[i+1]; next
            if sys.argv[i] == "-g2":
                files["geneFile2"] = sys.argv[i+1]; next
            if sys.argv[i] == "-r":
                files["inReportFile"] = sys.argv[i+1]; next
    else:
        print (USAGE_STRING)
        LOGFILE.close(); exit(0)
else:
    print (USAGE_STRING)
    LOGFILE.write("%s\n" % ("Incorrect number of command-line arguments provided"))
    LOGFILE.close(); exit(0)

# Check files
match = re.search(p_fasta, files["geneFile1"])
if not match:
    fileError = True
match = re.search(p_fasta, files["geneFile2"])
if not match:
    fileError = True
match = re.search(p_report, files["inReportFile"])
if not match:
    fileError = True
if fileError:
    print ("cgp_postProcessCGPM says, ERROR: Check the formats of your input files:")
    print ("  Gene fasta file #1:     ", files["geneFile1"])
    print ("  Gene fasta file #2:     ", files["geneFile2"])
    print ("  Report file:            ", files["inReportFile"])
    print (USAGE_STRING)
    LOGFILE.close(); exit(0)

# Open files
try:
    GENE_FILE1 = open(files["geneFile1"],"r")
except IOError as e:
    fileError = True
    print (e)
try:
    GENE_FILE2 = open(files["geneFile2"],"r")
except IOError as e:
    fileError = True
    print (e)
try:
    IN_REPORT_FILE = open(files["inReportFile"],"r")
except IOError as e:
    fileError = True
    print (e)
if fileError:
    print("cgp_postProcessCGPM says, ERROR: Problem opening a file; exiting now.")
    LOGFILE.close(); exit(0)

# Record to log and keep in touch with user
LOGFILE.write("%s" % ("Parameters are: \n"))
LOGFILE.write("%s%s%s" % ("gene file #1: ",files["geneFile1"],"\n"))
LOGFILE.write("%s%s%s" % ("gene file #2: ",files["geneFile2"],"\n"))
LOGFILE.write("%s%s%s" % ("report file:  ",files["inReportFile"],"\n"))

REPORT_FILE = open(files["outReportFile"],"w")  
REPORT_FILE.write("%s%s%s" % ("#gene file #1: ",files["geneFile1"],"\n"))
REPORT_FILE.write("%s%s%s" % ("#gene file #2: ",files["geneFile2"],"\n"))

if PHATE_PROGRESS:
    print ("cgp_postProcessCGPM says, Parameters are:")
    print ("  Gene file #1:", files["geneFile1"])
    print ("  Gene file #2:", files["geneFile2"])
    print ("  Input report file: ", files["inReportFile"])
    print ("  Output report file: ", files["outReportFile"])
if PHATE_MESSAGES:
    print ("  Parameters:")
    keys = list(parameters); keys.sort()
    for key in keys:
        print ("  ",key, "is", parameters[key])

#########################################################################
# Construct multi-fasta objects for geneFile1 and geneFile2 data sets

if PHATE_PROGRESS:
    print("cgp_postProcessCGPM says, Constructing multi-fasta objects for geneFile1 and geneFile2 data sets.")

fLines = GENE_FILE1.read().splitlines() # read lines into list, removing newlines
geneSet1 = fastaSequence.multiFasta()   # create multi-fasta object
geneSet1.addFastas(fLines,"nt")         # load it up!
GENE_FILE1.close()

fLines = GENE_FILE2.read().splitlines() # same for genome #2's genes
geneSet2 = fastaSequence.multiFasta()
geneSet2.addFastas(fLines,"nt")
GENE_FILE2.close()

#########################################################################
# Create nested array(list) data structure for inReportFile data

blastResults = []  # holds a list of dataLines
dataLine     = []  # holds a single blast result and additional data

# dataLine fields are as follows (0-23 taken from class blastAnalysis, method mergeAll):
# Fields for hitLine (0-19):
# 0: sortPostion                               - used below to sort all hitLines relative to genome 1
# 1: genome_hitType - "genome1"|"genome2" + "_" + "mutual"|"singular"|"loner"
# 2-5: qStart,qEnd,sStart,sEnd                 - query/subject start/end values from blast output
# 6-7: identity,evalue                         - from blast output
# 8: "query"|"subject"|"loner"
# 9: g1header                                  - header of genome 1 sequence
# 10: g1contig
# 11: annotations                              - annotations attached to query sequence
# 12-14: g1Start_onGenome,g1End_onGenome,g1Strand - genome1 gene/protein start/end
# 15: "query"|"subject"|"loner"
# 16: g2header                                 - header of genome2 sequence
# 17: g2contig
# 18: g2annotations                            - annotations attached to subject sequence
# 19-21: g2start_onGenome,g2end_onGenome,g2strand - subject gene/protein start/end on its genome
# 22: G1coverage                               - genome1's gene/protein coverage in blast hit
# 23: G2coverage                               - genome2's gene/protein coverage in blast hit
# 24: alignmentLength                          - reported by blast
# 25: gapopens                                 - reported by blast
# 26: g1span                                   - calculated
# 27: g1length                                 - calculated
# 28: g2span                                   - calculated
# 29: g2length                                 - calculated

# Messages to be inserted in comments field of data line
FLIP_STRAND_MSG = "Hit to reverse strand of sequence" 
SPLIT_GENE_MSG  = "Possible split gene call on genome"  
MISSING_SEGMENT_MSG = "Possible extra or missing domain"
ALTERNATE_START_MSG = "Possible alternate start codon"
OVERLAPPING_HIT_MSG = "Hits appear to overlap"
PARALOG_MSG         = "Could be paralog or gene duplication"
START_CODON_MSG     = "Check start codon on gene from genome"
ATG_CODON_MSG       = "Start codon is not ATG on gene from genome"

# Columns and their contents; all but ones at end exist in input report file 
# For readability, field numbers are set as constants:
SORT_POSITION      = 0
GENOME_HITTYPE     = 1
Q_START            = 2 
Q_END              = 3
S_START            = 4 
S_END              = 5 
IDENTITY           = 6 
EVALUE             = 7 
G1_HIT_TYPE        = 8 
G1_HEADER          = 9 
G1_CONTIG          = 10
G1_ANNOTATIONS     = 11   
G1_START_ON_GENOME = 12
G1_END_ON_GENOME   = 13
G1_STRAND          = 14
G2_HIT_TYPE        = 15
G2_HEADER          = 16
G2_CONTIG          = 17
G2_ANNOTATIONS     = 18
G2_START_ON_GENOME = 19
G2_END_ON_GENOME   = 20
G2_STRAND          = 21 
G1_COVERAGE        = 22
G2_COVERAGE        = 23
ALIGNMENT_LENGTH   = 24
GAP_OPENS          = 25
G1_SPAN            = 26
G1_LENGTH          = 27
G2_SPAN            = 28
G2_LENGTH          = 29
ALERT_LIST         = 30  # list of detected items of note and anomalies
G1_SEQUENCE        = 31  # fill this in if possible alternate start site(s)
G2_SEQUENCE        = 32  # ditto

#########################################################################
# Identify anomalous matches

prevDataList = []
prevG1cds = ""
prevG2cds = ""
prevG1start = 0
prevG1end   = 0
prevG2start = 0
prevG2end   = 0
prevQstart  = 0
prevSstart  = 0
prevQend    = 0
prevSend    = 0
alertList = []
alertString = ""
FLIPPED = False
PREVIOUS_FLIPPED = False

if PHATE_PROGRESS:
    print("cgp_postProcessCGPM says, Identifying anomalous matches.")

# if SIMILAR_GENOMES:  # assume closely related for now; 
IN_REPORT_FILE = open(files["inReportFile"],"r")
fLines = IN_REPORT_FILE.read().splitlines()
IN_REPORT_FILE.close()
#REPORT_FILE = open(files["outReportFile"],"w")  #*** already opened up at top
today = os.popen('date')
REPORT_FILE.write("%s%s%s" % ("#Post-processing of compareGeneProfiles.report on ", today.read(), "\n"))

if PHATE_PROGRESS:
    print("cgp_postProcessCGPM says, Processing report file lines")

for line in fLines:
    commentLine = re.search(p_comment, line)
    if commentLine or line == "":
        REPORT_FILE.write("%s%s" % (line,"\n"))
    else:
        # Set up a whole bunch of variables
        dataList = line.split('\t')
        dataList.append(""); dataList.append(""); dataList.append("") # make room for more data
        (genome,hitType) = dataList[GENOME_HITTYPE].split('_')  
        G1headerFields = dataList[G1_HEADER].split('/')
        G2headerFields = dataList[G2_HEADER].split('/')
        G1cds = G1headerFields[0]
        G2cds = G2headerFields[0] 
        if G1cds:
            G1start = int(dataList[G1_START_ON_GENOME])
            G1end   = int(dataList[G1_END_ON_GENOME])
        else:
            G1start = 0
            G1end   = 0
        if G2cds:
            G2start = int(dataList[G2_START_ON_GENOME])
            G2end   = int(dataList[G2_END_ON_GENOME])
        else:
            G2start = 0
            G2end   = 0
        G1distance = G1start - prevG1end  # measures distance between successive gene calls
        G2distance = G2start - prevG2end  # if real close, then might be split gene call
        if dataList[G1_COVERAGE]:
            G1coverage = int(dataList[G1_COVERAGE])
        else:
            G1coverage = 0
        if dataList[G2_COVERAGE]:
            G2coverage = int(dataList[G2_COVERAGE])
        else:
            G2coverage = 0
        if dataList[GAP_OPENS]:
            gapOpens   = int(dataList[GAP_OPENS])

        # Detect missing/added segments between matched genes, hits to reverse strand, and possible adjacent paralogs
        if hitType == "mutual" or hitType == "singular": 
            Qstart = int(dataList[Q_START])
            Qend   = int(dataList[Q_END])
            Sstart = int(dataList[S_START])
            Send   = int(dataList[S_END])
            if G1coverage < 0 or G2coverage < 0: # if coverage computes to negative, then hit was in reverse orientation 
                alertList.append("a)" + FLIP_STRAND_MSG)
                FLIPPED = True 
            if (gapOpens == 0 or gapOpens == 1) and abs(G1coverage - G2coverage) > parameters["COVERAGE_DIFF"]: # one seq may be missing a domain
                alertList.append("b)" + MISSING_SEGMENT_MSG) 
            if G1cds == prevG1cds:
                alertList.append("c)" + PARALOG_MSG + " on genome 2") # if same gene occurs twice, then possible paralogs on other genome...
            if G2cds == prevG2cds:                                       # ...or could be (more likely) split gene (catch below)
                alertList.append("d)" + PARALOG_MSG + " on genome 1")

            # Detect possible alternate start sites; PREVIOUS_FLIPPED gets set below, based on FLIPPED outcome
            if not PREVIOUS_FLIPPED:  # when previous hit was to reverse orientation, coverage goes negative, so calculation below is not meaningful
                if G1coverage >= parameters["NEARLY_FULL"] and (100 - G2coverage) >= parameters["COVERAGE_DIFF"]: # could exist alternate start codon 
                    if genome == "genome1":  # genome 2 gene is the subject
                        if abs(Sstart - prevSend) <= parameters["START_DIFF"]:  
                            alertList.append("e)" + ALTERNATE_START_MSG + " on genome 2") 
                            fasta = geneSet2.matchHeader(dataList[G2_HEADER])
                            ATGsequence = fasta.highlightAllStartCodons()
                            dataList[G2_SEQUENCE] = ATGsequence
                            #print "Sort loc is", dataList[0], "abs diff Sstart minus prevSend is", Sstart, "-", prevSend, "is", abs(Sstart - prevSend)
                    elif genome == "genome2":  # genome 2 gene is the query (#***???)
                        if abs(Qstart - prevQend) <= parameters["START_DIFF"]:
                            alertList.append("f)" + ALTERNATE_START_MSG + " on genome 2")
                            fasta = geneSet2.matchHeader(dataList[G2_HEADER])
                            ATGsequence = fasta.highlightAllStartCodons()
                            dataList[G2_SEQUENCE] = ATGsequence
                if G2coverage >= parameters["NEARLY_FULL"] and (100 - G1coverage) >= parameters["COVERAGE_DIFF"]: # could exist alternate start codon
                    if genome == "genome2":  # genome1 gene is the subject 
                        if abs(Sstart - prevSend) <= parameters["START_DIFF"]:  # genome1 gene is the subject
                            alertList.append("g)" + ALTERNATE_START_MSG + " on genome 1")
                            fasta = geneSet1.matchHeader(dataList[G1_HEADER])
                            ATGsequence = fasta.highlightAllStartCodons()
                            dataList[G1_SEQUENCE] = ATGsequence
                    elif genome == "genome1":  # genome 2 gene is the subject (#***???)
                        if abs(Qstart - prevQend) <= parameters["START_DIFF"]:
                            alertList.append("h)" + ALTERNATE_START_MSG + " on genome 1")
                            fasta = geneSet1.matchHeader(dataList[G1_HEADER])
                            ATGsequence = fasta.highlightAllStartCodons()
                            dataList[G1_SEQUENCE] = ATGsequence

            if G1distance == 0 or G1distance == 3:  # gene call could be split (0|1 codon apart)
                alertList.append("i)" + SPLIT_GENE_MSG + "1") 
                fasta = geneSet1.matchHeader(dataList[G1_HEADER])
                if fasta.getStartCodon().lower() != "atg":
                    alertList.append("k)" + ATG_CODON_MSG + "1") 
                sequence = fasta.highlightAllStartCodons()
                dataList[G1_SEQUENCE] = sequence
                startType = fasta.verifyProkaryoticStartCodon()
                alertList.append("m)" + START_CODON_MSG + "1, type is: " + startType)
            if G2distance == 0 or G2distance == 3:
                alertList.append("j)" + SPLIT_GENE_MSG + "2")
                fasta = geneSet2.matchHeader(dataList[G2_HEADER])
                if fasta.getStartCodon().lower() != "atg":
                    alertList.append("l)" + ATG_CODON_MSG + "2") 
                sequence = fasta.highlightAllStartCodons()
                dataList[G2_SEQUENCE] = sequence
                startType = fasta.verifyProkaryoticStartCodon()
                alertList.append("n)" + START_CODON_MSG + "2, type is: " + startType)
            prevQstart = Qstart
            prevQend   = Qend
            prevSstart = Sstart
            prevSend   = Send

        if hitType == "loner":
            if G1cds == prevG1cds:  # genome1_loner
                alertList.append("o)" + SPLIT_GENE_MSG + " on genome 1")
                #***  This section of code has redundancy due to confusion regarding set1 vs. set2
                fasta1 = geneSet1.matchHeader(dataList[G1_HEADER])
                fasta2 = geneSet2.matchHeader(dataList[G1_HEADER])
                fasta3 = geneSet1.matchHeader(dataList[G2_HEADER])
                fasta4 = geneSet2.matchHeader(dataList[G2_HEADER])
                if fasta1:
                    dataList[G1_SEQUENCE] = fasta1.sequence
                    startType = fasta1.verifyProkaryoticStartCodon()
                elif fasta2:
                    dataList[G1_SEQUENCE] = fasta2.sequence
                    startType = fasta2.verifyProkaryoticStartCodon()
                elif fasta3:
                    dataList[G2_SEQUENCE] = fasta3.sequence
                    startType = fasta3.verifyProkaryoticStartCodon()
                elif fasta4:
                    dataList[G2_SEQUENCE] = fasta4.sequence
                    startType = fasta4.verifyProkaryoticStartCodon()
                else:
                    dataList[G1_SEQUENCE] = "no sequence found"
                    startType = "unknown"
                alertList.append("q)" + START_CODON_MSG + "1, type is: " + startType)
            if G2cds == prevG2cds:  # genome2_loner
                alertList.append("p)" + SPLIT_GENE_MSG + " on genome 2")
                #***  This section of code has redundancy due to confusion regarding set1 vs. set2
                fasta1 = geneSet1.matchHeader(dataList[G1_HEADER])
                fasta2 = geneSet2.matchHeader(dataList[G1_HEADER])
                fasta3 = geneSet1.matchHeader(dataList[G2_HEADER])
                fasta4 = geneSet2.matchHeader(dataList[G2_HEADER])
                if fasta1:
                    dataList[G1_SEQUENCE] = fasta1.sequence
                    startType = fasta1.verifyProkaryoticStartCodon()
                elif fasta2:
                    dataList[G1_SEQUENCE] = fasta2.sequence
                    startType = fasta2.verifyProkaryoticStartCodon()
                elif fasta3:
                    dataList[G2_SEQUENCE] = fasta3.sequence
                    startType = fasta3.verifyProkaryoticStartCodon()
                elif fasta4:
                    dataList[G2_SEQUENCE] = fasta4.sequence
                    startType = fasta4.verifyProkaryoticStartCodon()
                else:
                    dataList[G2_SEQUENCE] = "no sequence found"
                    startType = "unknown"
                alertList.append("r)" + START_CODON_MSG + "2, type is: " + startType)

        prevDataList = dataList
        prevG1cds   = G1cds
        prevG2cds   = G2cds
        prevG1start = G1start
        prevG1end   = G1end
        prevG2start = G2start
        prevG2end   = G2end
        PREVIOUS_FLIPPED = FLIPPED
        FLIPPED = False

        # write newly annotated data line to output report file
        for alert in alertList:
            alertString = alertString + "; " + alert 
        alertString = alertString.lstrip(';')
        dataList[ALERT_LIST] = alertString
        for data in dataList:
            REPORT_FILE.write("%s%s" % (data,"\t"))
        REPORT_FILE.write("%s" % ("\n"))
        alertList = []  # reset
        alertString = ""

if PHATE_PROGRESS:
    print("cgp_postProcessCGPM says, Post processing complete.")

REPORT_FILE.close() 
LOGFILE.close()
