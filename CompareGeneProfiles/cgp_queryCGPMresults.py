#!/usr/bin/env python3
#######################################################
#
# Name: queryCGPMresults.py
#
# Programmer:  Carol L. Ecale Zhou
#
# Last update:  21 December 2020
#
#################################################################
# This code was developed by Carol L. Ecale Zhou at Lawrence Livermore National Laboratory.
# THIS CODE IS COVERED BY THE GPL3 LICENSE. SEE INCLUDED FILE GPL-3.PDF FOR DETAILS.

import sys, os, re, string, copy
import subprocess

#DEBUG = True
DEBUG = False

CODE_BASE_DIR = os.environ["CGP_CODE_BASE_DIR"]

# Set messaging booleans
PHATE_PROGRESS = False
PHATE_MESSAGES = False
PHATE_WARNINGS = False
PHATE_PROGRESS_STRING = os.environ["PHATE_PHATE_PROGRESS"]
PHATE_MESSAGES_STRING = os.environ["PHATE_PHATE_MESSAGES"]
PHATE_WARNINGS_STRING = os.environ["PHATE_PHATE_WARNINGS"]
if PHATE_PROGRESS_STRING.lower() == 'true':
    PHATE_PROGRESS = True
if PHATE_MESSAGES_STRING.lower() == 'true':
    PHATE_MESSAGES = True
if PHATE_WARNINGS_STRING.lower() == 'true':
    PHATE_WARNINGS = True

if PHATE_MESSAGES:
    print("cgp_queryCGPMresults says, Begin processing.")

#### FILES

inFile            = ""  # list of directories to query. By default all 'Results_' dirs in cwd are queried, but can be user designated subset 
outFile           = os.path.join(CODE_BASE_DIR, "queryCGPMresults.user.out")   # default, but should be user designated
queryFile         = os.path.join(CODE_BASE_DIR, "queryCGPMresults.query")     # holds intermediate results from grepping report file for genome_hitType
logFile           = os.path.join(CODE_BASE_DIR, "queryCGPMresults.log")
ppCGPM_logFile    = "postProcessCGPM.log"           # file by this name in each 'Results_' directory
ppCGPM_reportFile = "postProcessCGPM.report"        # file by this name in each 'Results_' directory
LOGFILE = open(logFile,"w")
LOGFILE.write("%s\n" % ("Begin log file"))

#### CONSTANTS

MAX_PARAMS = 7   # currently, user can specify up to 7 parameters (not counting the '-letter' preceding the parameter)

HELP_STRING = "Script queryCGPMresults.py searches results files generated by compareGeneProfiles_main.py/postProcessCGPM.py and returns a list of matches. For more information, type: queryCGPMresults.py usage, or queryCGPMresults.py input."

USAGE_STRING = "Usage:  python3 queryCGPMresults.py -g <1|2|3> -s <nt|aa> -h <loner|singular|mutual> -d <dirFile.lst> -o <outFile> -i <i1,i2,i3> -c <cds1,cds2,cds3> (optional parameters, comprising interpretation strings or cds numbers, separated by comma; use -i or -c but not both)"

INPUT_STRING = """Input:  The following parameters may be provided: 
   genome number (1 or 2, or 3 if both) (default: 3)
   sequence type (nt or aa) (default: nt)
   hit type (loner, singular, or mutual best) (default: loner)
   name of a file containing a list of the directories to search (default: none, will read from current directory)
       Note: directories need to be fully qualified (ie, full path provided), 
       or you may provide a common directory under which all directories are 
       located by specifying: baseDir=<dir> as a separate line in your input file. 
       For an example of a correctly formatted input file, see queryCGPMresults.infile.sample.txt. 
   name of the output file where query results will be written (default: queryCGPMresults.user.out)
   Format your input as follows:
       -g 1|2|3 -s nt|aa -h loner|singular|mutual -d <dirsfile> -o <outfile>
   You may also (optinally) provide one or more interpretation codes separated by comma (no spaces between): 
       -i <extra,split,reverse,paralog,alternate,overlap> Note: if more than one, separate with comma (no spaces)
         Meaning:  
           extra = extra or missing domain
           split = split gene call
           reverse = gene call is on reverse strand
           paralog = paralog or gene duplication
           alternate = alternate start codon
           overlap = overlapping genes
   You may also query all of the hits for one or more coding sequences by providing a comma-separated list of numbers:  
        -c <123,456,78910>
"""

GENOME = False; SEQUENCE_TYPE = False; HIT_TYPE = False; INFILE_PARAM = False; OUTFILE_PARAM = False; INTERPRETATION_PARAM = False
ANY = True; 
FLIP = False; 
SPLIT = False; 
XTRA = False; 
ALTERNATE = False; 
OVERLAP = False; 
PARALOG = False; 
NOT_ATG = False; 
CDS = False
# CDS is True if query is for all hits for a given coding sequence (cds number) #*** ???

##### Get command-line arguments

genomeOrdering = 3         # default:  both genomes
sequenceType = "nt"        # default:  nucleotide
hitType = "loner"          # default:  loners (i.e., unique genes)
interpretationString = ""  # from user input
interpretationCodes  = []  # user-input list split by ','
interpretationCode   = ""
cdsList = []
cdsString = ""
cdsNumber = ""

# This is rather complicated, but it filters some possible user error in
# providing the wrong number of command-line arguments, for example
# leaving out the "-letter" prefix for a parameter.

if PHATE_PROGRESS:
    print("cgp_queryCGPMresults says, Gathering input.")

ACCEPTABLE_ARG_COUNT = []  
ACCEPTABLE_ARG_COUNT.append(2)      # if only argument is 'help' etc. 
for x in xrange((MAX_PARAMS+1)*2):  # otherwise, arguments come in pairs (eg, -d <dirsList>)
    if x % 2 == 1:  # x is odd      # recall: sys.argv[0] is the code itself
        ACCEPTABLE_ARG_COUNT.append(x)

if PHATE_PROGRESS:
    print("cgp_queryCGPMresults says, Determining query type(s).")
argCount = len(sys.argv)
if argCount in ACCEPTABLE_ARG_COUNT:
    if argCount == 2:
        match = re.search("help", sys.argv[1].lower())
        if match:
            print (HELP_STRING)
            exit(0)
        match = re.search("input", sys.argv[1].lower())
        if match:
            print (INPUT_STRING)
            exit(0)
        match = re.search("usage", sys.argv[1].lower())
        if match:
            print (USAGE_STRING)
            exit(0)
    else:
        for i in xrange(argCount):
            if sys.argv[i] == "-g":  # 1 or 2, for genome1 or genome2, and 3 for both, 0 for a single cds, regardless of hit type
                if sys.argv[i+1] == "1" or sys.argv[i+1] == "2" or sys.argv[i+1] == "3" or sys.argv[i+1] == "0":
                    genomeOrdering = sys.argv[i+1].lower()
                    GENOME = True

            if sys.argv[i] == "-s":  # 'nt' or 'aa', for gene or protein
                match = re.search('nt|nucl|gene|dna|aa|prot|peptide|protein', sys.argv[i+1].lower())
                if match:
                    sequenceType = sys.argv[i+1].lower()
                    SEQUENCE_TYPE = True

            if sys.argv[i] == "-h":  # 'loner', 'singular', 'mutual_best', for type of hit
                match = re.search('loner|unique|singular|mutual|best|any|all', sys.argv[i+1].lower())
                if match:
                    hitType = sys.argv[i+1].lower()
                    HIT_TYPE = True

            if sys.argv[i] == "-d":  # directories list filename
                inFile = sys.argv[i+1]
                INFILE_PARAM = True
 
            if sys.argv[i] == "-o":  # output filename
                outFile = sys.argv[i+1]
                OUTFILE_PARAM = True

            if sys.argv[i] == "-i":  # interpretation code (optional)
                interpretationString = sys.argv[i+1]
                INTERPRETATION_PARAM = True
                interpretationCodes = interpretationString.split(',')
                for code in interpretationCodes:
                    match = re.search('extra',code.lower())       # extra or missing domain
                    if match:
                        XTRA = True; ANY = False
                    match = re.search('missing',code.lower())
                    if match:
                        XTRA = True; ANY = False
                    match = re.search('flip',code.lower())        # gene on reverse strand
                    if match:
                        FLIP = True; ANY = False
                    match = re.search('reverse',code.lower())
                    if match:
                        FLIP = True; ANY = False
                    match = re.search('alternate',code.lower())   # alternate start codon
                    if match:
                        ALTERNATE = True; ANY = False
                    match = re.search('overlap',code.lower())     # overlapping genes
                    if match:
                        OVERLAP = True; ANY = False
                    match = re.search('paralog',code.lower())     # paralog or gene duplication
                    if match:
                        PARALOG = True; ANY = False
                    match = re.search('dup',code.lower())         
                    if match:
                        PARALOG = True; ANY = False
                    match = re.search('start',code.lower())       # alternate start codon
                    if match:
                        ALTERNATE = True; ANY = False
                    match = re.search('not',code.lower())         # start codon not ATG
                    if match:
                        NOT_ATG = True; ANY = False

            if sys.argv[i] == "-c":  # coding sequence number provided
                cdsString = sys.argv[i+1]
                cdsList = cdsString.split(',')
                CDS = True

    if PHATE_MESSAGES:
        print ("cgp_queryCGPMresults says, Query will be run with the following parameters:")
        print ("  genome ordering =", genomeOrdering)
        print ("  sequence type =", sequenceType)
        print ("  hit type =", hitType)
        if inFile:
            print ("  inFile =", inFile)
        else:
            print ("  inFile = none provided; using current directory list")
        print ("  outFile =", outFile)
        print ("  cds number =", cdsList)
        print ("  interpretation codes are", interpretationCodes)

    LOGFILE.write("%s\n"   % ("Parameter files are: "))
    LOGFILE.write("%s%s\n" % ("    genomeOrdering: ",genomeOrdering))
    LOGFILE.write("%s%s\n" % ("    sequenceType: ",sequenceType))
    LOGFILE.write("%s%s\n" % ("    hitType: ",hitType))
    if inFile:
        LOGFILE.write("%s%s\n" % ("    inFile: ",inFile))
    else:
        LOGFILE.write("%s\n" % ("    inFile: none provided; using current directory list"))
    LOGFILE.write("%s%s\n" % ("    outFile: ",outFile))
    LOGFILE.write("%s%s\n" % ("    interpretation codes: ",interpretationCodes))
    LOGFILE.write("%s%s\n" % ("    cds numbers: ",cdsList))

else:
    print (HELP_STRING)
    print (USAGE_STRING)
    print (INPUT_STRING)
    exit(0)

##### Open files and get list of Results directories to query

directoryList = []
baseDir = "./"  # default is current working directory

match = re.search('\w',inFile)  # If user provided infile w/dir names, then use it
if match:
    if PHATE_PROGRESS:
        print("cgp_queryCGPMresults says, Reading input file ",inFile)
    LOGFILE.write("%s%s\n" % ("Reading input file ",inFile))
    INFILE = open(inFile,"r")
    fLines = INFILE.read().splitlines()
    numLines = len(fLines)
    if PHATE_MESSAGES:
        print("cgp_queryCGPMresults says, Number of lines in input file with directories list is",numLines)
    LOGFILE.write("%s%s\n" % ("Number of lines in input file with directories list is ", numLines)) 
    for i in xrange(0,numLines):
        line = fLines[i]
        match = re.search('baseDir',line)
        if match:
            (preamble,baseDir) = line.split('=')
        else:
            match = re.search('\w+', line)
            if match:
                directoryList.append(line)

else:  # If no infile w/dir names was provided, then assume Results dirs are in current working directory 
    command = "ls . | grep \'Results_\'"  # Get list of Results directories in current directory
    proc = subprocess.Popen([command], stdout=subprocess.PIPE, shell=True) 
    (out, err) = proc.communicate()
    if err:
        print ("cgp_queryCGPMresults says, ERROR:", err)
    out = out.rstrip()  # remove pesky terminal newline character
    directoryList = out.split('\n')

# Check directoryList
if PHATE_PROGRESS:
    print ("cgp_queryCgPMresults says, directoryList is", directoryList)

OUTFILE = open(outFile,"w")
#QUERY_FILE = open(queryFile,"w")

##### Construct and run queries

sysCommand = "> " + queryFile  # Reminder: queryFile holds intermediate results
os.system(sysCommand)          # create or initialize query.out file 

LOGFILE.write("%s\n" % ("Reading input directories and gathering information"))
if PHATE_PROGRESS:
    print("cgp_queryCGPMresults says, Reading input directories and gathering information.")

ONE = False
TWO = False
if genomeOrdering == 1:
    ONE = True
if genomeOrdering == 2:
    TWO = True
if genomeOrdering == 3:
    ONE = True; TWO = True

if PHATE_PROGRESS:
    print ("cgp_queryCGPMresults says, Processing Results directories...")
for dir in directoryList:
    nextDir = baseDir + dir
    nextLog = nextDir + "/" + ppCGPM_logFile
    NEXT_LOG = open (nextLog,"r")
    fLines = NEXT_LOG.read().splitlines()
    for line in fLines:
        match = re.search('#1',line)
        if match:
            columns = line.split(' ')
            genome1 = columns[3]
        match = re.search('#2',line)
        if match:
            columns = line.split(' ')
            genome2 = columns[3]
    NEXT_LOG.close()

    #nextReport = nextDir + "/" + ppCGPM_reportFile
    sysCommand = "echo \'##### Querying directory\' " + nextDir + " >> " + queryFile
    os.system(sysCommand)
    sysCommand = "echo \'# Gene Set 1 is\' " + genome1 + " >> " + queryFile
    os.system(sysCommand)
    sysCommand = "echo \'# Gene Set 2 is\' " + genome2 + " >> " + queryFile
    os.system(sysCommand)

    if CDS and cdsList != []:
        for cds in cdsList:
            nextCDS = "cds" + cds + "/"
            sysCommand = "grep \'" + nextCDS + "' " + nextDir + "/" + "postProcessCGPM.report >> " + queryFile
            os.system(sysCommand) 
    else:
        if ONE:
            queryString = "genome1_" + hitType  #
            sysCommand = "grep \'" + queryString + "' " + nextDir + "/" + "postProcessCGPM.report >> " + queryFile
            os.system(sysCommand)
        if TWO:
            queryString = "genome2_" + hitType  # 
            sysCommand = "grep \'" + queryString + "' " + nextDir + "/" + "postProcessCGPM.report >> " + queryFile
            os.system(sysCommand)

##### Process raw query text and write to users output file

fields = []  # holds column values from .report file
POS            = 0
GENOME_TYPE    = 1
Q_START        = 2
Q_END          = 3
S_START        = 4
S_END          = 5
IDENTITY       = 6
EVALUE         = 7
QLS1           = 8
G1HEADER       = 9
G1CONTIG       = 10
G1ANNOTATION   = 11
G1GENE_START   = 12
G1GENE_END     = 13
G1STRAND       = 14
QLS2           = 15
G2HEADER       = 16
G2CONTIG       = 17
G2ANNOTATION   = 18
G2GENE_START   = 19
G2GENE_END     = 20
G2STRAND       = 21
G1COVERAGE     = 22
G2COVERAGE     = 23
ALIGN_LENGTH   = 24
GAP_OPENS      = 25
G1SPAN         = 26
G1LENGTH       = 27
G2SPAN         = 28
G2LENGTH       = 29
INTERPRETATION = 30
G1SEQUENCE     = 31
G2SEQUENCE     = 32

### From postProcessCGPM.py:
FLIP_STRAND_MSG     = "Hit to reverse strand of sequence"
SPLIT_GENE_MSG      = "Possible split gene call on genome"
MISSING_SEGMENT_MSG = "Possible extra or missing domain"
ALTERNATE_START_MSG = "Possible alternate start codon"
OVERLAPPING_HIT_MSG = "Hits appear to overlap"
PARALOG_MSG         = "Could be paralog or gene duplication"
START_CODON_MSG     = "Check start codon on gene from genome"
ATG_CODON_MSG       = "Start codon is not ATG on gene from genome"

QUERY_FILE = open(queryFile,"r")
dataLine = ""
EMPTY = "[]"  #*** For now, annotation fields are empty for protein entries
fLines = QUERY_FILE.read().splitlines()
if PHATE_MESSAGES:
    print ("cgp_queryCGPMresults says, Number of lines in query file: ", len(fLines))

if PHATE_PROGRESS:
    print("cpg_queryCGPMresults says, Selecting lines with query criteria.")
count = 0
for line in fLines:
    DO_SELECT = False
    match = re.search('^#',line)
    if match:
        OUTFILE.write("%s\n" % (line))
    else:
        match = re.search('^\d',line)
        if match:
            fields = line.split('\t')
            dataLine = fields[POS]  # always record the position (1st field in tabbed data)
            (genome,hitType) = fields[GENOME_TYPE].split('_')  # will need to determine which kind of hit this is
            if fields[G1ANNOTATION] != EMPTY or fields[G2ANNOTATION] != EMPTY:  #*** Improve this: was skipping protein records
                #if hitType == "mutual":  # always reported as genome1 hits
                #dataLine = dataLine + "\t" + fields[GENOME_TYPE] + "\t" + fields[G1HEADER] + "\t" + fields[G1ANNOTATION]
                #if hitType == "singular":

                if hitType == "mutual" or hitType == "singular":
                    dataLine = dataLine + "\t" + fields[GENOME_TYPE] + "\t" + fields[G1HEADER] + "\t" + fields[G1CONTIG] + "\t" + fields[G1ANNOTATION] + "\t" + fields[G2HEADER]
                    dataLine = dataLine + "\t" + fields[G2CONTIG] + "\t" + fields[G2ANNOTATION] + "\tG1len=" + fields[G1LENGTH] + "\tG2len=" + fields[G2LENGTH]
                    if FLIP:
                        match = re.search(FLIP_STRAND_MSG,fields[INTERPRETATION])
                        if match:
                            dataLine = dataLine + "\t" + fields[INTERPRETATION]
                            DO_SELECT = True
                    elif SPLIT:
                        match = re.search(SPLIT_GENE_MSG,fields[INTERPRETATION])
                        if match:
                            dataLine = dataLine + "\t" + fields[INTERPRETATION]
                            DO_SELECT = True
                    elif XTRA:
                        match = re.search(MISSING_SEGMENT_MSG,fields[INTERPRETATION])
                        if match:
                            dataLine = dataLine + "\t" + fields[INTERPRETATION]
                            DO_SELECT = True
                    elif ALTERNATE:
                        match = re.search(ALTERNATE_START_MSG,fields[INTERPRETATION])
                        if match:
                            dataLine = dataLine + "\t" + fields[INTERPRETATION]
                            DO_SELECT = True
                    elif OVERLAP:
                        match = re.search(OVERLAPPING_HIT_MSG,fields[INTERPRETATION])
                        if match:
                            dataLine = dataLine + "\t" + fields[INTERPRETATION]
                            DO_SELECT = True
                    elif PARALOG:
                        match = re.search(PARALOG_MSG,fields[INTERPRETATION])
                        if match:
                            dataLine = dataLine + "\t" + fields[INTERPRETATION]
                            DO_SELECT = True
                    elif NOT_ATG:
                        match = re.search(ATG_CODON_MSG,fields[INTERPRETATION])
                        if match:
                            dataLine = dataLine + "\t" + fields[INTERPRETATION]
                            DO_SELECT = True
                    elif ANY:
                        dataLine = dataLine + "\t" + fields[INTERPRETATION]
                        DO_SELECT = True
                if hitType == "loner":
                    if genome == "genome1":
                        if fields[G1ANNOTATION] != EMPTY:  #*** improve this; was skipping protein records
                            DO_SELECT = True 
                            dataLine = dataLine + "\t" + fields[GENOME_TYPE] + "\t" + fields[G1HEADER] + "\t" + fields[G1CONTIG] + "\t" + fields[G1ANNOTATION] + "\tG1len=" + fields[G1LENGTH] 
                    if genome == "genome2":
                        if fields[G2ANNOTATION] != EMPTY:  #*** ditto
                            DO_SELECT = True
                            dataLine = dataLine + "\t" + fields[GENOME_TYPE] + "\t" + fields[G2HEADER] + "\t" + fields[G2CONTIG] + "\t" + fields[G2ANNOTATION] + "\tG2len=" + fields[G2LENGTH]
                if DO_SELECT:
                    OUTFILE.write("%s\n" % (dataLine))
                    count += 1
print ("Number of hits in out file: ", count)
QUERY_FILE.close()

##### Clean up

if inFile:
    INFILE.close()
OUTFILE.close()
LOGFILE.close()
if PHATE_PROGRESS:
    print("cgp_queryCGPMresults says, Processing complete.")
